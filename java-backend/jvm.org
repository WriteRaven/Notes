#+title

* 方法论
  1. 通过事情学习vs想别人学习
     站在巨大的肩膀上。
     自己一步一个门槛的试错，是经验主义者的桎梏。但是个体的小白鼠太过渺小，如果能够利用群体的的试错经验，
     先进个体的成功经验，会降低成本，增加收益。
     在时间跟精力有限的客观环境下，降低成本，增加效率/收益，才能够持续健康的成长。
     
  2. 技术更新太快，感觉知识学不完？
     反思过往，总结经验；以不变应万变。
     
     不可能把所有的天下的知识全部都学下来。
     淡水要在学习某一门经验的过程中，不断的总结规律，不断抽象经验教训，才能够让自己在举一反三，以不变应万变。
     
  3. 为什么学了一门知识之后，一段时间后会忘掉？
     可以把人的大脑皮层必做一台正在运行的程序。
     
     输入时(学习时)，大脑皮层会对这些知识非常的敏感，所以当时会有一种“学会的”认知。
     但是，因为大脑皮层神经元的活跃具有时效性，所以问题的根因就是没有持久化。
     如同内存中的数据，虽然运行很快，但是没有持久化。
     
     *怎么持久化？*
     程序的持久化效果是通过不同的输出。可以分为两种表现形式，一是不断的向其他系统输出，二是持久化于硬件。
     答案呼之欲出——输出。可以通过不断地应用/教学，可以通过好记性不如烂笔头。
     私以为，两者相辅相成，才能有最好的效果——费曼学习法。

  4. 视频不要超过三遍
     学习的过程中，就要不断把知识点文本化。
     不仅是一种输出，还因为视频的一个致命缺点在于不能够检索。
     
* jvm学习方法

** 难点
   1. 理论多
   2. 概念抽象
   3. 不易实践
* 学习内容

** TODO JVM介绍[0/1]
   
*** TODO 类加载 classloading
    SCHEDULED: <2021-08-05 四> DEADLINE: <8/6>
    DEADLINE: <8/6 -1>
    Java代码中，类型(class/interface/array)的加载，连接，初始化都是在程序运行期间完成的。

    其他编译型语言的连接一般是在编译阶段完成。
    java在运行期间做事情使java语言具有了动态语言的特性。

**** 类加载过程
     1. 加载
	将硬盘或网络字节码文件加载到内存里面。通过IO将字节码加载到内存的过程。

	* 详细过程
	  将类的.class文件中的二进制数据读入到内存中，
	  将其防止运行时数据区的方法区中，
	  在内存中创建一个java.lang.Class对象(类对象)(jvm Specifies并未言明类对象放置在哪里，hotspot将其放在了方法区中)
	  用来封装类在方法区/M etaSpace内的数据结构。

	* 加载.class文件的方式
	  - 本地系统中直接加载
	  - 通过网络下载的.class文件
	  - zip,jar等归档文件中加载.class文件
	  - 从专有数据库中提取.class文件
	  - 将java源文件动态编译为.class文件,即在运行时生成.class
	    动态代理会实现
	    jsp->sevlet
     
     2. 连接
	- 验证
	  确保被加载类的正确性。 因为class文件是可读写的
	- 准备
	  为类的*静态变量*分配内存，并将其初始化为默认值。
	- 解析  
	  把类与类之间的符号引用转换成直接引用。

	  #+BENGIN_TODO
	    **符号引用:** 通过符号进行引用？？
	    _直接引用:_ 通过指针引用
	  #+END_TODO

     3. 初始化
	对类的静态变量赋予正确的初始值.
	/所有的Java虚拟机实现必须在每个类或接口被java程序 *首次主动使用* 时才初始化他们。/

        - 初始化顺序
          [[./src/jvm/classload_initializeOrder_newClass_extendedClass.jpg][new Class()-初始化流程图]]
          
     4. 使用
	- 主动使用
           #+CAPTION: 类主动使用方式一览表
           #+NAME:   tab:basic-data
           | Java代码层面                        | 字节码指令   | 初始化类型      | 初始化内容                                               |
           |-------------------------------------+--------------+-----------------+----------------------------------------------------------|
           | 创建类的实例                        | NEW          | 类对象 实例对象 | 非继承：静态成员/static块->普通成员/非static块->构造函数 |
           |                                     |              |                 | 继承：父/子静态初始化->父类初始化->子类初始化            |
           | 访问类/接口的变量                   | GETSTATIC    | 类对象          | 父/子类static块->调用的静态变量                          |
           | 对静态变量赋值                      | PUTFIELD     | 类对象          |                                                          |
           | 调用类的静态方法                    | INVOKESTATIC |                 |                                                          |
           | 反射                                |              |                 |                                                          |
           | 初始化一个类的子类,父类也会被初始化 |              |                 |                                                          |
           | Java虚拟机启动时被标明为启动类的类  |              |                 |                                                          |
           | jdk7开始提供动态语言支持            |              |                 |                                                          |
           |-------------------------------------+--------------+-----------------+----------------------------------------------------------|

	   [[asm4-guide.pdf][字节码指令参考自asm4-guide]]

	- 被动使用
	  除主动使用的情形外，其他使用java类的方式都被看作是类的 *被动使用* ，
	  都不会导致类的 *初始化* 。
        
      5. demo Conclusion
       
           | conclusion                                         | demo  | 说明                                    |   |
           |----------------------------------------------------+-------+-----------------------------------------+---|
           | 调用静态字段时，只有定义了该字段的类才会被初始化  | demo1 | 输出MyCHIld1.strP时，先初始化静态代码块 |   |
           | 一个类初始化时，需要等父类先初始化完成             | demo1 |                                         |   |
           |                                                    |       |                                         |   |

**** demo
     * demo1
	  #+BEGIN_SRC java :classname Test
                        public class Test {
                            public static void main(String[] args) {
                                System.out.println("Hello world!");
                                System.out.println("++++++++++++out: MyChild1.strP");
                                System.out.println(MyChild1.strP);
                                System.out.println("++++++++++++out: MyChild2.strC2");
                                System.out.println(MyChild2.strC2);
                                System.out.println("++++++++++++out: MyChild2.strC2");
                                System.out.println(new MyChild2());
                            }
                        }

                        class MyParent1{
                            public static String strP = "hello , world";
                            static {
                               System.out.println("myParent1 static block");
                            }
                        }
                        class MyChild1 extends MyParent1{
                         static {
                             System.out.println("myChild1 static block");
                         }
                        }
            class MyChild2 extends MyParent1 {
                public static String strC2 = "hello, child-2";
                static{
                    System.out.println("myCHild2.static");
                }
            }
          #+END_SRC
          #+RESULTS:
          | Hello             | world!         |       |
          | ++++++++++++out:  | MyChild1.strP  |       |
          | myParent1         | static         | block |
          | hello             | ,              | world |
          | ++++++++++++out:  | MyChild2.strC2 |       |
          | myCHild2.static   |                |       |
          | hello,            | child-2        |       |
          | ++++++++++++out:  | MyChild2.strC2 |       |
          | MyChild2@2a139a55 |                |       |

     5. 卸载
	osgi会使用
**** 类加载器 classLoader
     类加载器是实现类加载的程序。
**** 虚拟机结束生命周期的情形
     + 正常情况
       1) 执行System.exit()方法
       2) 程序执行结束
     + 异样情况下	 
       1) 执行过程中遇到了错误或异常而终止
       2) 操作系统出现错误而导致java虚拟机进程终止 - 虚拟机运行的环境出现问题
	  

    
    
** HotSpot虚拟机讲解

   
** 垃圾收集方式详解

** 垃圾收集算法详解

** 垃圾收集齐详解
   
** 分代垃圾收集机制
   
** 新生代
   
** 老年代
   
** G1收集器分析与实例
   
** JVM参数
   
*** JVM参数格式
    | 格式             | 说明                        |
    |------------------+-----------------------------|
    | -XX:+option      | 表示开启option选项          |
    | -XX:-option      | 表示关闭option选项          |
    | -XX:option=value | 表示将option的值设置为value |

*** 常见
    | 参数                   | 说明                         |
    |------------------------+------------------------------|
    | -XX:+TradeClassLoading | 追踪并顺序打印出类的加载信息 |
    |                        |                              |
   
** 栈

** 方法区

** 线程共享内存区

** 根搜索算法

** Serial收集器

** ParNew收集器

** 类加载机制详解
   
** 类加载的双亲委托机制

** 字节码文件生成与分析

** 魔数

** 常量池与方法表

** 各种指令详解

** 锁详解

** 线程安全

** 偏向锁/自旋锁/轻量级锁

** JIT编译器

** GC日志生成与分析

** 虚拟机监控工具

** jConsole使用方式

** 逃逸&逃逸分析

** 方法内联

** 虚拟机内存模型详解

* babeltest
  
** uml
      todo-test uml
      #+begin_src plantuml :file ./src/jvm/my-diagram.png
 title Authentication Sequence

 Alice->Bob: Authentication Request
 note right of Bob: Bob thinks about it
 Bob->Alice: Authentication Response
 #+end_src

 #+RESULTS:
 file:./src/jvm/my-diagram.png
