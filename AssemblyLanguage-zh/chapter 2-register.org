* 第二章  寄存器 - CPU工作原理（内部通讯） 

** 寄存器基本概念
   
   1. CPU组成
      运算器，控制器，寄存器等(属于内部器件) 

   2. 内部总线
      - 定义
        实现CPU内部各个器件之间的联系
      - 与外部总线区别
        外部总线实现CPU与主板上其它器件的联系
   
   3. 寄存器（8086为例）

      1. 概念
         8086CPU的寄存器共14个，并且都是16位的(最大存储数据(2^16-1))，可以存放两个字节

         - 8086CPU的14个寄存器
            | AX | BX  | CX | DX |
            | SI | DI  | SP | BP |
            | IP | CS  | SS | DS |
            | ES | PSW |    |    |
        
      2. 通用寄存器
         AX,BX,CX,DX通常用来存放一般性的数据，被称为通用寄存器

      3. 寄存器逻辑结构
         [[./src/2-register-logic structure.png]]
           
      4. 存储器的数据存放
         
         - 存储示意图
           [[./src/2-register-data in AX register.png]]

      5. 存储器最大值
         n=存储器位数
         2^n - 1

         - eg:8位存储器存储的最大值
           2^8 - 1
           
      6. 寄存器兼容性
         因为8086上一代CPU的寄存器都是8位的，为保证兼容性，
         这四个通用寄存器都可以拆分为两个独立的8位寄存器使用。
         
         - 拆分示意图 （H：高位； L：低位）
             | 16位 | 拆分高位 | 拆分低位 |
             |------+----------+----------|
             | AX   | AH       | AL       |
             | BX   | BH       | BL       |
             | CX   | CH       | CL       |
             | DX   | CH       | CL       |

         - 示意图
           8086中，AX分成AH和AL：
           [[./src/2-register-divide one 16-bit into two 8-bit.png]]
         
       
** '字'在寄存器中的存储
   一个字‘word’用2B存储,刚好存储与16位寄存器,
   一个字 - 即一个字符

   - 进制符号
     | 进制名 | 进制符号 |
     |--------+----------|
     | 2进制  | B (Bin)  |
     | 16进制 | H        |
     | 10进制 | 无       |


** 几条汇编指令
   汇编命令不区分大小写!

   | 汇编语言      | CPU操作                                     | 高级语言描述     |
   |---------------+---------------------------------------------+------------------|
   | =mov reg,data= | 将data存入reg                               | =reg = data=     |
   | =add reg,data= | 将寄存器中的数据与data相加,并将其存入寄存器 | =reg = reg+data= |
   | =add reg1,reg2= | 将reg1,reg2的数据相加，并存入reg1           | =reg1 = reg1+reg2= |
   ps:reg,reg1,reg2 为某一寄存器
   
   - demo:
      | 汇编指令    | CPU操作                         | 高级语言描述   |
      |-------------+---------------------------------+----------------|
      | =mov ax,18= | 将18送入AX                      | =AX = 18=      |
      | =mov ah,78= | 将78送服AH                      | =AH = 78=      |
      | =add ax,8=  | 将寄存器AX中的数值加上8         | =AX = AX + 8=  |
      | =mov ax,bx= | 将寄存器BX中的数据送入寄存器AX  | =AX = BX=      |
      | =add ax,bx= | 将AX,BX的数据相加，将结果存入AX | =AX = AX + BX= |
   

** 物理地址   
   CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间。
   这个唯一的地址称之为物理空间。


** 16位结构的CPU
   
   - 用16位结构描述一个CPU的特征：
     
     1. 运算器一次最多可以处理16位的数据

     2. 通用寄存器的最大宽度位16位

     3. 寄存器和运算器之间的通路是16位的
        
      - ps：以上特征决定CPU位数结构(e.g. 16位/32位/64位）
      - ps：8位一个字节：8 bits = 1 Byte
        

** 8086CPU给出的物理地址的方法

   1. 8086CPU中CPU数据传输冲突

     8086CPU有20位的地址总线，可传送20位地址，寻址能力为1M(2^20=1MB)
     8086CPU内部位16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K(2^16=64KB)

   2. 解决上述冲突方法
      
        8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址

      - 步骤
        
        1. CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个成为i偏移地址
        2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件
        3. 地址加法器将两个16位地址合并成一个20位的地址
        4. 输出至20位的地址总线，寻址

      - 示意图
        [[./src/2-register-8086CPU generate address.png]]

   3. 地址加法器合成物理地址
      - 合成物理地址的方法
        物理地址 = 段地址*16 + 偏移地址
        ps:段地址*16，又称将数据左移4位

        - 本质
          基础地址+偏移地址 = 物理地址
          
      - 工作过程示意图
        [[./src/2-register-address adder.png]]

      - 进制移动
        一个数据的X进制形式左移1位，相当于乘以X
        - demo
          [[./src/2-register-moving bit.png]]

        - 移位次数与数据关系
          1. 一个数据的二进制形式左移一位，相当于该数据乘2
          2. 一个数据的二进制形式左移n位，相当于该数据乘2^n
          3. 一个数据的m进制形式左移一位，相当于该数据乘m
          4. 一个数据的m进制左移n位，相当于该数据乘n
             
      - 仅用偏移地址寻址
        偏移地址为16位，变化范围位0~FFFFH,给定段地址，仅用偏移地址最多可寻64K个内存单元。
      
   4. 地址加法器实现段地址*16的方法
      将以二进制形式存放的段地址左移4位

   5. 根据物理地址寻找段地址和偏移地址
      - 不同段地址，偏移地址生成相同物理地址
        - demo
          [[./src/2-register-address conflict.png]]

        - 解决方法
          NULL
      

** 段 - segmentation
      - 概念
        内存并没有被划分成一个个段
        段的划分来自CPU,由于物理地址的生成方式给出内存单元的物理地址，
        从而造成‘分段’，因此可以用分段的方式管理内存.
      - 示意图
        [[./src/2-register-segmentation.png]]
      
      - 编程中的应用
        因此,在编程时可以根据需要，将若干地址连续的内存单元看作一个段，
        用*段地址*16*来_定位_的*起始地址*，用*偏移地址*_定位_*段的内存单元*。
        
        - 注意
          1. 段地址*16必然是16的倍数，所以一个段的起始地址也一定是16的倍数
          2. 偏移地址为16位,16位地址的寻址能力为64K,所以一个段的长度最大为64K


        - 代码段
          存放代码的段
   

** 段寄存器
   
   1. 概念
      提供段地址的寄存器

   2. 8086中的段寄存器
      当8086CPU访问内存时,由这4个段寄存器提供内存单元的地址

      |CS|DS|
      |SS|ES|

   3. CS和IP
      CS:代码段寄存器
      IP:指令指针寄存器
      
      二者是8086中最关键的寄存器,它们指示了CPU当前要读取指令的地址.
      换言之，内存中任一北CPU执行过的信息，都被CS:IP指向过

   4. 读写工作流程

      1. 从CS：IP只想内存单元读取指令，读取的指令进入指令缓冲器
      2. IP = IP + 所读取指令的长度，从而指向下一条指令
      3. 执行指令。转到步骤1，重复该过程
      
      4. 流程图
         [[./src/2-register-CS IP read and write.png]]

   5. 修改CS:IP的指令
      1. 同时修改CS,IP内容：
         jmp - 转移指令
         =jmp 段地址：偏移地址=
         - demo
           =jmp 2AE3:3=
           =jmp 3:OB16=

      2. 仅修改IP内容
         jmp + mov
         =jmp ax data=
         =mov IP,ax=

      3. demo
         [[./src/2-register/CS IP Jmp case.png]]
         
         - answer
           #+BEGIN_SRC 
             mov ax, 6622  //1
             jmp 1000:3    //2
             mov ax,000    //3
             mov bx,ax     //4
             jmp bx        //5
             mov ax,0123H  //6
             转到第3步执行  //7
           #+END_SRC

   6. 8086CPU开机启动过程

      1. 在CPU加电启动或复位后(即CPU刚开始工作时)，CS和IP被设置为 *CS=FFFFH* , *IP=0000H*

      2. PC机刚启动时，CPU从内存 *FFFF0* 单元中读取指令执行
         ( *FFFF0H* 单元中的指令时PC机开机后执行的第一条指令) 

** 实验1 - 查看CPU和内存，用机器指令和汇编指令编程
   
*** 预备知识 - debug的使用
    - 开启
      cmd debug
    - 命令
      | 命令 | 功能                                     |
      |------+------------------------------------------|
      | R    | 查看，改变CPU寄存器的内容                |
      | D    | 查看内存中的内容                         |
      | E    | 改写内存中的内容                         |
      | U    | 将内存中的机器指令翻译成汇编指令         |
      | T    | 执行一条机器指令                         |
      | A    | 以汇编指令的格式在内存中写入一条机器指令 |
